{"version":3,"sources":["../src/edge.ts"],"names":["init","coreFlush"],"mappings":"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","file":"edge.mjs","sourcesContent":["/**\n * @outboundiq/nextjs/edge\n * \n * Edge runtime support for Next.js middleware and edge API routes\n * \n * @example\n * ```typescript\n * // In Edge API route or middleware\n * import { trackFetch } from '@outboundiq/nextjs/edge';\n * \n * export const runtime = 'edge';\n * \n * export async function GET(request: Request) {\n *   // Manually track a fetch in edge runtime\n *   const response = await trackFetch('https://api.example.com/data', {\n *     method: 'GET',\n *   });\n *   \n *   return Response.json(await response.json());\n * }\n * ```\n */\n\nimport { init, track, getClient, flush as coreFlush, type OutboundIQConfig, type UserContext } from '@outboundiq/core';\n\nlet isInitialized = false;\n\n/**\n * Ensure SDK is initialized\n */\nfunction ensureInitialized(): boolean {\n  if (isInitialized || getClient()) {\n    return true;\n  }\n\n  const apiKey = process.env.OUTBOUNDIQ_KEY;\n  const endpoint = process.env.OUTBOUNDIQ_URL;\n\n  if (!apiKey) {\n    console.warn('[OutboundIQ] Missing OUTBOUNDIQ_KEY environment variable');\n    return false;\n  }\n\n  init({\n    apiKey,\n    endpoint,\n    debug: process.env.OUTBOUNDIQ_DEBUG === 'true',\n    batchSize: 1, // Send immediately for serverless\n    flushInterval: 1000,\n  });\n\n  isInitialized = true;\n  console.log('[OutboundIQ] Auto-initialized for trackFetch');\n  return true;\n}\n\n/**\n * Initialize OutboundIQ for Edge runtime\n * Call this once at the start of your edge function\n */\nexport function initEdge(config?: Partial<OutboundIQConfig>): void {\n  if (isInitialized) return;\n\n  const apiKey = config?.apiKey || process.env.OUTBOUNDIQ_KEY;\n\n  if (!apiKey) {\n    console.warn('[OutboundIQ] Missing API key for edge runtime');\n    return;\n  }\n\n  init({\n    apiKey,\n    endpoint: config?.endpoint || process.env.OUTBOUNDIQ_URL,\n    debug: config?.debug || process.env.OUTBOUNDIQ_DEBUG === 'true',\n    // Smaller batches for edge (short-lived)\n    batchSize: config?.batchSize || 5,\n    flushInterval: config?.flushInterval || 1000,\n    ...config,\n  });\n\n  isInitialized = true;\n}\n\n/**\n * Track a fetch request manually\n * Auto-initializes SDK if not already done\n */\nexport async function trackFetch(\n  input: RequestInfo | URL,\n  init?: RequestInit & { userContext?: UserContext }\n): Promise<Response> {\n  // Auto-initialize if needed\n  const initialized = ensureInitialized();\n  \n  const startTime = performance.now();\n  const url = typeof input === 'string' ? input : input instanceof URL ? input.toString() : input.url;\n  const method = init?.method || 'GET';\n  const userContext = init?.userContext;\n\n  // Remove our custom property before passing to fetch\n  const fetchInit = init ? { ...init } : undefined;\n  if (fetchInit) {\n    delete (fetchInit as any).userContext;\n  }\n\n  try {\n    const response = await fetch(input, fetchInit);\n    const duration = performance.now() - startTime;\n\n    // Track the call if initialized\n    if (initialized) {\n      track({\n        method: method.toUpperCase(),\n        url,\n        statusCode: response.status,\n        duration,\n        userContext: userContext || null,\n      });\n      \n      // Flush immediately for serverless (request may end soon)\n      await coreFlush();\n    }\n\n    return response;\n  } catch (error) {\n    const duration = performance.now() - startTime;\n\n    if (initialized) {\n      track({\n        method: method.toUpperCase(),\n        url,\n        statusCode: 0,\n        duration,\n        error: error instanceof Error ? error.message : 'Unknown error',\n        userContext: userContext || null,\n      });\n      \n      await coreFlush();\n    }\n\n    throw error;\n  }\n}\n\n/**\n * Create a tracked fetch function with pre-configured user context\n */\nexport function createTrackedFetch(userContext: UserContext) {\n  return async function trackedFetch(\n    input: RequestInfo | URL,\n    init?: RequestInit\n  ): Promise<Response> {\n    return trackFetch(input, { ...init, userContext });\n  };\n}\n\n// Re-export useful functions\nexport { track, flush, setUserContext } from '@outboundiq/core';\nexport type { UserContext } from '@outboundiq/core';\n\n// ============================================\n// SDK Methods: recommend, providerStatus, endpointStatus\n// ============================================\n\n/**\n * Common options for SDK methods\n */\ninterface SdkMethodOptions {\n  userContext?: UserContext;\n  requestId?: string;\n}\n\n/**\n * Recommendation response from the API\n */\ninterface RecommendResponse {\n  success: boolean;\n  service?: {\n    name: string;\n    description: string;\n    strategy: string;\n  };\n  recommendation?: {\n    provider: string;\n    endpoint: string;\n    confidence: number;\n    reason: string;\n  };\n  alternatives?: Array<{\n    provider: string;\n    endpoint: string;\n    confidence: number;\n  }>;\n  error?: string;\n}\n\n/**\n * Provider status response from the API\n */\ninterface ProviderStatusResponse {\n  success: boolean;\n  provider?: {\n    name: string;\n    slug: string;\n    status: string;\n    description: string;\n  };\n  metrics?: {\n    success_rate: number;\n    average_latency: number;\n    total_requests: number;\n  };\n  incidents?: Array<{\n    title: string;\n    status: string;\n    created_at: string;\n  }>;\n  error?: string;\n}\n\n/**\n * Endpoint status response from the API\n */\ninterface EndpointStatusResponse {\n  success: boolean;\n  endpoint?: {\n    name: string;\n    slug: string;\n    method: string;\n    url_pattern: string;\n  };\n  metrics?: {\n    success_rate: number;\n    average_latency: number;\n    total_requests: number;\n  };\n  provider?: {\n    name: string;\n    status: string;\n  };\n  error?: string;\n}\n\n/**\n * Get the base API URL from environment\n */\nfunction getBaseUrl(): string {\n  // Use the main API, not the metric endpoint\n  const endpoint = process.env.OUTBOUNDIQ_URL || 'https://agent.outboundiq.dev/api/metric';\n  // Convert metric endpoint to base API URL\n  // https://agent.outboundiq.dev/api/metric â†’ https://agent.outboundiq.dev/api\n  return endpoint.replace('/metric', '');\n}\n\n/**\n * Get recommendation for a service\n * \n * Returns the best provider/endpoint to use based on:\n * - Your actual API usage data (success rate, latency, stability)\n * - Provider status page health\n * - Recent incidents\n * \n * @example\n * ```typescript\n * const result = await recommend('payment-processing');\n * if (result?.success && result.recommendation) {\n *   console.log(`Use ${result.recommendation.provider} (${result.recommendation.confidence}% confidence)`);\n * }\n * ```\n */\nexport async function recommend(\n  serviceName: string,\n  options: SdkMethodOptions = {}\n): Promise<RecommendResponse | null> {\n  const apiKey = process.env.OUTBOUNDIQ_KEY;\n  if (!apiKey) {\n    console.warn('[OutboundIQ] Missing API key for recommend()');\n    return null;\n  }\n\n  try {\n    const url = `${getBaseUrl()}/v1/recommend/${encodeURIComponent(serviceName)}`;\n    const requestId = options.requestId || crypto.randomUUID();\n\n    const headers: Record<string, string> = {\n      'Authorization': `Bearer ${apiKey}`,\n      'Accept': 'application/json',\n      'X-Request-Id': requestId,\n    };\n\n    if (options.userContext) {\n      headers['X-User-Context'] = JSON.stringify(options.userContext);\n    }\n\n    const response = await fetch(url, {\n      method: 'GET',\n      headers,\n    });\n\n    return await response.json();\n  } catch (error) {\n    console.error('[OutboundIQ] recommend() failed:', error);\n    return null;\n  }\n}\n\n/**\n * Get status and metrics for a provider\n * \n * Returns real-time actionable data for decision-making:\n * - Provider status (from status page)\n * - Aggregate metrics (success rate, latency)\n * - Active incidents\n * \n * @example\n * ```typescript\n * const status = await providerStatus('stripe');\n * if (status?.provider?.status === 'operational') {\n *   // Safe to use Stripe\n * }\n * ```\n */\nexport async function providerStatus(\n  providerSlug: string,\n  options: SdkMethodOptions = {}\n): Promise<ProviderStatusResponse | null> {\n  const apiKey = process.env.OUTBOUNDIQ_KEY;\n  if (!apiKey) {\n    console.warn('[OutboundIQ] Missing API key for providerStatus()');\n    return null;\n  }\n\n  try {\n    const url = `${getBaseUrl()}/v1/provider/${encodeURIComponent(providerSlug)}/status`;\n\n    const headers: Record<string, string> = {\n      'Authorization': `Bearer ${apiKey}`,\n      'Accept': 'application/json',\n    };\n\n    if (options.userContext) {\n      headers['X-User-Context'] = JSON.stringify(options.userContext);\n    }\n\n    const response = await fetch(url, {\n      method: 'GET',\n      headers,\n    });\n\n    return await response.json();\n  } catch (error) {\n    console.error('[OutboundIQ] providerStatus() failed:', error);\n    return null;\n  }\n}\n\n/**\n * Get status and metrics for a specific endpoint\n * \n * Returns real-time actionable data for decision-making:\n * - Endpoint-specific metrics (success rate, latency)\n * - Provider status\n * - Active incidents\n * \n * @example\n * ```typescript\n * const status = await endpointStatus('stripe-post-charges');\n * if (status?.metrics?.success_rate > 99) {\n *   // Endpoint is healthy\n * }\n * ```\n */\nexport async function endpointStatus(\n  endpointSlug: string,\n  options: SdkMethodOptions = {}\n): Promise<EndpointStatusResponse | null> {\n  const apiKey = process.env.OUTBOUNDIQ_KEY;\n  if (!apiKey) {\n    console.warn('[OutboundIQ] Missing API key for endpointStatus()');\n    return null;\n  }\n\n  try {\n    const url = `${getBaseUrl()}/v1/endpoint/${encodeURIComponent(endpointSlug)}/status`;\n\n    const headers: Record<string, string> = {\n      'Authorization': `Bearer ${apiKey}`,\n      'Accept': 'application/json',\n    };\n\n    if (options.userContext) {\n      headers['X-User-Context'] = JSON.stringify(options.userContext);\n    }\n\n    const response = await fetch(url, {\n      method: 'GET',\n      headers,\n    });\n\n    return await response.json();\n  } catch (error) {\n    console.error('[OutboundIQ] endpointStatus() failed:', error);\n    return null;\n  }\n}\n\n/**\n * Axios interceptor types\n */\ninterface AxiosResponse {\n  status: number;\n  config: {\n    url?: string;\n    method?: string;\n    baseURL?: string;\n    headers?: Record<string, string>;\n    data?: unknown;\n    metadata?: { startTime: number };\n  };\n  headers?: Record<string, string>;\n  data?: unknown;\n}\n\ninterface AxiosError {\n  config?: AxiosResponse['config'];\n  response?: AxiosResponse;\n  message: string;\n}\n\ninterface AxiosInstance {\n  interceptors: {\n    request: {\n      use: (\n        onFulfilled?: (config: any) => any,\n        onRejected?: (error: any) => any\n      ) => number;\n    };\n    response: {\n      use: (\n        onFulfilled?: (response: any) => any,\n        onRejected?: (error: any) => any\n      ) => number;\n    };\n  };\n  \n  get: <T = any>(url: string, config?: any) => Promise<{ data: T; status: number; headers: any; config: any }>;\n  post: <T = any>(url: string, data?: any, config?: any) => Promise<{ data: T; status: number; headers: any; config: any }>;\n  put: <T = any>(url: string, data?: any, config?: any) => Promise<{ data: T; status: number; headers: any; config: any }>;\n  patch: <T = any>(url: string, data?: any, config?: any) => Promise<{ data: T; status: number; headers: any; config: any }>;\n  delete: <T = any>(url: string, config?: any) => Promise<{ data: T; status: number; headers: any; config: any }>;\n  head: <T = any>(url: string, config?: any) => Promise<{ data: T; status: number; headers: any; config: any }>;\n  options: <T = any>(url: string, config?: any) => Promise<{ data: T; status: number; headers: any; config: any }>;\n  request: <T = any>(config: any) => Promise<{ data: T; status: number; headers: any; config: any }>;\n  // Instance properties\n  defaults: any;\n}\n\n/**\n * Add OutboundIQ tracking to an existing axios instance\n * \n * This adds interceptors without removing existing ones.\n * Works with any axios instance that already has interceptors.\n * \n * @example\n * ```typescript\n * import axios from 'axios';\n * import { addAxiosTracking } from '@outboundiq/nextjs/edge';\n * \n * // Your existing axios instance with interceptors\n * const api = axios.create({ baseURL: 'https://api.example.com' });\n * api.interceptors.request.use(config => {\n *   config.headers.Authorization = `Bearer ${token}`;\n *   return config;\n * });\n * \n * // Add OutboundIQ tracking (doesn't remove existing interceptors)\n * addAxiosTracking(api);\n * \n * // Now all calls are tracked!\n * await api.get('/users');\n * ```\n */\nexport function addAxiosTracking(\n  axiosInstance: AxiosInstance,\n  options?: { userContext?: UserContext }\n): void {\n  // Ensure SDK is initialized\n  ensureInitialized();\n\n  // Request interceptor - record start time\n  axiosInstance.interceptors.request.use(\n    (config: any) => {\n      config.metadata = { startTime: performance.now() };\n      return config;\n    },\n    (error: any) => Promise.reject(error)\n  );\n\n  // Response interceptor - track successful calls\n  axiosInstance.interceptors.response.use(\n    async (response: AxiosResponse) => {\n      const duration = response.config.metadata?.startTime\n        ? performance.now() - response.config.metadata.startTime\n        : 0;\n\n      const url = buildAxiosUrl(response.config);\n\n      track({\n        method: (response.config.method || 'GET').toUpperCase(),\n        url,\n        statusCode: response.status,\n        duration,\n        userContext: options?.userContext || null,\n      });\n\n      // Flush for serverless\n      await coreFlush();\n\n      return response;\n    },\n    async (error: AxiosError) => {\n      const duration = error.config?.metadata?.startTime\n        ? performance.now() - error.config.metadata.startTime\n        : 0;\n\n      const url = error.config ? buildAxiosUrl(error.config) : 'unknown';\n\n      track({\n        method: (error.config?.method || 'GET').toUpperCase(),\n        url,\n        statusCode: error.response?.status || 0,\n        duration,\n        error: error.message,\n        userContext: options?.userContext || null,\n      });\n\n      await coreFlush();\n\n      return Promise.reject(error);\n    }\n  );\n}\n\n/**\n * Build full URL from axios config\n */\nfunction buildAxiosUrl(config: AxiosResponse['config']): string {\n  const baseURL = config.baseURL || '';\n  const url = config.url || '';\n  \n  if (url.startsWith('http://') || url.startsWith('https://')) {\n    return url;\n  }\n  \n  return baseURL + url;\n}\n\n/**\n * Create a tracked axios instance\n * \n * @example\n * ```typescript\n * import axios from 'axios';\n * import { createTrackedAxios } from '@outboundiq/nextjs/edge';\n * \n * const api = createTrackedAxios(axios, {\n *   baseURL: 'https://api.example.com',\n * });\n * \n * await api.get('/users'); // Automatically tracked!\n * ```\n */\nexport function createTrackedAxios(\n  axios: { create: (config?: any) => AxiosInstance },\n  config?: any,\n  options?: { userContext?: UserContext }\n): AxiosInstance {\n  const instance = axios.create(config);\n  addAxiosTracking(instance, options);\n  return instance;\n}\n\n"]}