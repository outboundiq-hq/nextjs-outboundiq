{"version":3,"sources":["../src/middleware.ts"],"names":["NextResponse"],"mappings":"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","file":"middleware.js","sourcesContent":["/**\n * @outboundiq/nextjs/middleware\n * \n * Middleware utilities for user context injection\n * \n * @example\n * ```typescript\n * // middleware.ts\n * import { withOutboundIQ } from '@outboundiq/nextjs/middleware';\n * import { getToken } from 'next-auth/jwt';\n * \n * export default withOutboundIQ(async (request) => {\n *   // Your middleware logic\n *   return NextResponse.next();\n * }, {\n *   // Optional: custom user resolver\n *   getUserContext: async (request) => {\n *     const token = await getToken({ req: request });\n *     return token ? { userId: token.sub, context: 'authenticated' } : null;\n *   }\n * });\n * ```\n */\n\nimport { NextRequest, NextResponse } from 'next/server';\nimport type { UserContext } from '@outboundiq/core';\n\n/**\n * Options for the OutboundIQ middleware wrapper\n */\nexport interface WithOutboundIQOptions {\n  /**\n   * Custom function to extract user context from the request\n   */\n  getUserContext?: (request: NextRequest) => Promise<UserContext | null> | UserContext | null;\n\n  /**\n   * Patterns to exclude from tracking\n   */\n  excludePatterns?: (string | RegExp)[];\n}\n\n/**\n * Header name for passing user context to API routes\n */\nexport const USER_CONTEXT_HEADER = 'x-outboundiq-user-context';\n\n/**\n * Default user context resolver\n * Attempts to extract user info from common patterns\n */\nasync function defaultGetUserContext(request: NextRequest): Promise<UserContext | null> {\n  // Try to get user ID from common header patterns\n  const userId = \n    request.headers.get('x-user-id') ||\n    request.headers.get('x-authenticated-user') ||\n    null;\n\n  // Check for NextAuth session cookie\n  const hasNextAuthSession = request.cookies.has('next-auth.session-token') ||\n    request.cookies.has('__Secure-next-auth.session-token');\n\n  // Check for Clerk session\n  const hasClerkSession = request.cookies.has('__session') ||\n    request.cookies.has('__clerk_db_jwt');\n\n  // Check for Authorization header\n  const hasAuthHeader = request.headers.has('authorization');\n\n  // Determine context type\n  let context: UserContext['context'] = 'anonymous';\n  if (userId || hasNextAuthSession || hasClerkSession || hasAuthHeader) {\n    context = 'authenticated';\n  }\n\n  // Check if it's an API call vs page request\n  const isApiRoute = request.nextUrl.pathname.startsWith('/api');\n  if (isApiRoute && hasAuthHeader) {\n    context = 'api';\n  }\n\n  return {\n    userId: userId ? String(userId) : null,\n    context,\n    metadata: {\n      path: request.nextUrl.pathname,\n      method: request.method,\n    },\n  };\n}\n\n/**\n * Wrap your middleware with OutboundIQ user context injection\n */\nexport function withOutboundIQ(\n  middleware: (request: NextRequest) => Promise<NextResponse> | NextResponse,\n  options: WithOutboundIQOptions = {}\n): (request: NextRequest) => Promise<NextResponse> {\n  const { getUserContext = defaultGetUserContext, excludePatterns = [] } = options;\n\n  return async function outboundIQMiddleware(request: NextRequest): Promise<NextResponse> {\n    const url = request.nextUrl.pathname;\n\n    // Check exclusions\n    for (const pattern of excludePatterns) {\n      if (typeof pattern === 'string' && url.includes(pattern)) {\n        return middleware(request);\n      }\n      if (pattern instanceof RegExp && pattern.test(url)) {\n        return middleware(request);\n      }\n    }\n\n    // Get user context\n    const userContext = await getUserContext(request);\n\n    // Call the original middleware\n    const response = await middleware(request);\n\n    // Inject user context header for downstream API routes\n    if (userContext) {\n      const contextHeader = JSON.stringify(userContext);\n      response.headers.set(USER_CONTEXT_HEADER, contextHeader);\n    }\n\n    return response;\n  };\n}\n\n/**\n * Extract user context from request headers (for API routes)\n */\nexport function getUserContextFromRequest(request: Request): UserContext | null {\n  const contextHeader = request.headers.get(USER_CONTEXT_HEADER);\n  if (!contextHeader) return null;\n\n  try {\n    return JSON.parse(contextHeader) as UserContext;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Create a simple middleware that just injects user context\n * Use this if you don't have existing middleware\n */\nexport function createOutboundIQMiddleware(\n  options: WithOutboundIQOptions = {}\n): (request: NextRequest) => Promise<NextResponse> {\n  return withOutboundIQ(\n    () => NextResponse.next(),\n    options\n  );\n}\n\n"]}